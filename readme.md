
# Doodle jump project

## Введение

Хеш-табли́ца — это структура данных, реализующая интерфейс ассоциативного массива, разбивающая данные на основе значений некоторой хеш-функции.  
Так как размер хеш-таблицы на практике сильно меньше количества данных, при добавлении очередного значения его хеш может совпасть с некоторым уже хранящимся значением. Такая ситуация называется коллизией.  
Существует несколько способов обработки коллизий, однако в этой работе мы ограничимся методом цепочек. Он заключается в том, что данные с одинаковым хешом хранятся в связном списке, указатель на начало которого хранится в соответствующей ячейке хеш-таблицы.

Легко заметить, что длинные цепочки замедляют работу с таблицей. Поэтому, эффективность таблицы сильно зависит от используемой хеш-функции. Хорошая хеш-функция минимизирует количество коллизий благодаря равномерному распределению значений на любом наборе входных данных.

## Цель работы
Цель работы заключается в поиске оптимальных хеш-функций для сортировки текста.
Были протестированы слудющие функции:  
+ constant_one - всегда возвращает единицу  
+ first_char   - возвращает значение первого байта в строке  
+ strlen       - возвращает длину строки  
+ sum_char     - возвращает сумму байт в строке  
+ rorxor       - для каждого байта строки выполняет: hash = (hash xor byte) ror 1  
+ rolxor       - для каждого байта строки выполняет: hash = (hash xor byte) rol 1  
+ crc32        - широко используемая функция, выполняющая деление с остатком двоичных многочленов  

## Метод тестирования

В хэш-таблицу загружались все слова из романа Дж. Оруэлла "1984", после производился замер длины полученных цепочек. Компиляция проводилась при флагах компиляции -O2 -mavx2.

## Результаты

В начале размер хеш-таблицы был выбран равным 19, размеры цепочек показаны на следующих графиках:

<img src="work/func_test_results/size 19/all.svg"  width="800"/>
<img src="work/func_test_results/size 19/no_1.svg" width="800"/>

Уже сейчас нетрудно заметить, что значения функция strlen обладают распределением, близким к нормальному, вследствие чего она не подходит для нашей задачи.  
Функция first_char также явно "отдает предпочтение" некоторым значениям, соответсвующим самым частым буквам английского алфавита.  
Остальные функции на данном этапе выдают приемлемое распределение значений.

Длины цепочек для хеш-таблицы размером 499 предлставлены на следующих графиках:

<img src="work/func_test_results/size 499/all.svg"    width="800"/>
<img src="work/func_test_results/size 499/no_123.svg" width="800"/>

Объясним такое неравномерное, по сравнению с другими функциями, распределение значений rorxor на данном этапе. Хэш-функция возвращает значение типа int, имеющего длину 32 бита. Большинство слов в английском языке имеют длину менее 12 слов. Для них во время выполнения функции *rorxor* происходит не более 12 поворотов направо, вследствие чего получившиеся значения отличаются лишь старшими 12-ю битами и младшими 8-ю (в середине остаются биты одного значения). При взятии этих значений по модулю длины хеш-таблицы, информация о старших 12 битах частично теряется.

## Итог

Из всех использованных функций актуальными для использования, как мне кажется, являются следующие:  
+ sum_char - нормальное распределение ее значений начинает проявляеться только при размерах таблицы в несколько тысяч ячеек. Большой ее плюс - простота написания.  
+ Из функций rorxor и rolxor, как показала практика, предпочтение явно стоит отдать последней.  
+ Функция crc32 выдает самое равномерное распределение значений, однако несколько сложнее в написании, чем другие.

При описанных ограничениях все эти функции являются подходящими для использования в хеш-таблицах.

# Вторая часть работы

## Цель работы

Цель работы заключается в оптимизации времени работы программы, использующей хеш-таблицу.  
Она сначала добавляет в нее слова из романа "1984", а после ищет в ней слова из романа "Мастер и Маргарита" и выводит процент найденных слов.  


## Ход работы

Был произведен запуск базовой версии программы с профилированием с помощью программы gprof. Были получены следующие результаты:

<img src="work/opt_results/19.png" width="800"/>

Версия программы | Время работы, ms   | Абсолютный коеффициент ускорения | Относительный коэффициент ускорения
----------------:|:------------------:|:--------------------------------:|:------------------
Базовая                     |  42781 $\pm$ 950     |    1                 |     -


Как видно из нижней части графа, выполнение хеш-функции hf_crc32 занимает целых 69 процентов времени выполнения прораммы.

Во второй версии эта функция была оптимизирована при помощи интринсика _mm_crc32_u8 из библиотеки "immintrin.h".
Ниже приведены результаты замеров времени работы второй версии программы:

<img src="work/opt_results/19_intrin.png" width="600"/>

Версия программы | Время работы, ms   | Абсолютный коеффициент ускорения | Относительный коэффициент ускорения
----------------:|:------------------:|:--------------------------------:|:------------------
Базовая                     |  42781 $\pm$ 950     |    1                 |     -
Оптимизация с интринсиками  |  15680 $\pm$ 313     |    2.72  $\pm$ 0.08  |     2.72  $\pm$ 0.41


Теперь более половины времени работы программы занимает выполнение функции my_strcmp, использующейся для поиска слов в цепочках. Наиболее очевидной оптимизацией в данном случае будет увеличение размера хеш-таблицы. Новый размер
был взят равным 499.

<img src="work/opt_results/499_intrin.png" width="600"/>

Версия программы | Время работы, ms   | Абсолютный коеффициент ускорения | Относительный коэффициент ускорения
----------------:|:------------------:|:--------------------------------:|:------------------
Базовая                     |  42781 $\pm$ 950     |    1                 |     -
Оптимизация с интринсиками  |  15680 $\pm$ 313     |    2.72  $\pm$ 0.08  |     2.72  $\pm$ 0.41
Оптимизация размера таблицы |  780   $\pm$ 15      |    54.85 $\pm$ 1.62  |     20.10 $\pm$ 0.92


В качестве дальнейшей оптимизации, перепишем функцию hf_crc32 на чистом ассемблере.  
Это можно сделать двумя способами: ассемблерная вставка внутри тела функции и подлинковка  
ассемблерного файла. Ниже приведены результаты замеров времени работы программы при этих оптимизациях.  
(сперва для вставки, после для подлинковки)

<img src="work/opt_results/499_inline.png" width="400"/>
<img src="work/opt_results/499_link.png"   width="600"/>

Версия программы | Время работы, ms   | Абсолютный коеффициент ускорения | Относительный коэффициент ускорения
----------------:|:------------------:|:--------------------------------:|:------------------
Базовая                     |  42781 $\pm$ 950     |    1                 |     -
Оптимизация с интринсиками  |  15680 $\pm$ 313     |    2.72  $\pm$ 0.08  |     2.72  $\pm$ 0.41
Оптимизация размера таблицы |  780   $\pm$ 15      |    54.85 $\pm$ 1.62  |     20.10 $\pm$ 0.92
Ассемблерная вставка        |  577   $\pm$ 12      |    74.14 $\pm$ 2.22  |     1.35  $\pm$ 0.13
Ассемблерная подлинковка    |  690   $\pm$ 13      |    62.00 $\pm$ 2.34  |     1.13  $\pm$ 0.12

## Вывод

Самой эффективной оптимизацией оказался простой подбор правильного параметра таблицы.  
Использование интринсиков также дало значительный прирост в производительности.  
использование ассемблерной вставки также помогает выиграть несколько десятков процентов в скорости работы программы,  однако подлинковка дает чуть меньший прирост. (скорее всего, из-за невозможности inline'a хеш-функции).

