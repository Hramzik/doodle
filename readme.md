
# Лабраторная работа по сравнению хеш-функций

## Введение

Хеш-табли́ца — это структура данных, реализующая интерфейс ассоциативного массива, разбивающая данные на основе значений некоторой хеш-функции.  
Так как размер хеш-таблицы на практике сильно меньше количества данных, при добавлении очередного значения его хеш может совпасть с некоторым уже хранящимся значением. Такая ситуация называется коллизией.  
Существует несколько способов обработки коллизий, однако в этой работе мы ограничимся методом цепочек. Он заключается в том, что данные с одинаковым хешом хранятся в связном списке, указатель на начало которого хранится в соответствующей ячейке хеш-таблицы.

Легко заметить, что длинные цепочки замедляют работу с таблицей. Поэтому, эффективность таблицы сильно зависит от использцемой хеш-функции. Хорошая хеш-функция минимизирует количество коллизий благодаря равномерному распределению значений на любом наборе входных данных.

## Цель работы
Цель работы заключается в поиске оптимальных хеш-функций для сортировки текста.
Были протестированы слудющие функции:  
+ constant_one - всегда возвращает единицу  
+ first_char   - возвращает значение первого байта в строке  
+ strlen       - возвращает длину строки  
+ sum_char     - возвращает сумму байт в строке  
+ rorxor       - для каждого байта строки выполняет: hash = (hash xor byte) ror 1  
+ rolxor       - для каждого байта строки выполняет: hash = (hash xor byte) rol 1  
+ crc32        - известная функция, выполняющая деление с остатком двоичных многочленов  

## Метод тестирования

В хэш-таблицу загружались все слова из романа Дж. Оруэлла "1984", после производился замер длины полученных цепочек.

## Результаты

В начале размер хеш-таблицы был выбран равным 19, размеры цепочек показаны на следующих графиках:

<img src="work/func_test_results/size 19/all.svg"  width="500"/>
<img src="work/func_test_results/size 19/no_1.svg" width="500"/>

Уже сейчас нетрудно заметить, что значения функция strlen обладают распределением, близким к нормальному, вследствие чего она не подходит для нашей задачи.  
Функция first_char также явно "отдает предпочтение" некоторым значениям, соответсвующим самым частым буквам английского алфавита.  
Остальные функции на данном этапе выдают приемлемое распределение значений.

Длины цепочек для хеш-таблицы размером 499 предлставлены на следующих графиках:

<img src="work/func_test_results/size 499/all.svg"    width="500"/>
<img src="work/func_test_results/size 499/no_123.svg" width="500"/>

Объясним такое неравномерное, по сравнению с другими функциями, распределение значений rorxor на данном этапе. Хэш-функция возвращает значение типа int, имеющего длину 32 бита. Большинство слов в английском языке имеют длину менее 12 слов. Для них во время выполнения функции rorxor происходит не более 12 поворотов направо, вследствие чего получившиеся значения отличаются лишь старшими 12-ю битами и младшими 8-ю (в середине остаются биты одного значения). При взятии этих значений по модулю длины хеш-таблицы, информация о старших 12 битах частично теряется.

## Итог

Из всех использованных функций актуальными для использования, как мне кажется, являются следующие:  
+ sum_char - нормальное распределение ее значений начинает проявляеться только при размерах таблицы в несколько тысяч ячеек. Большой ее плюс - простота написания.  
+ Из функций rorxor и rolxor, как показала практика, предпочтение явно стоит отдать последней.  
+ Функция crc32 выдает самое равномерное распределение значений, однако несколько сложнее в написании, чем другие.

При описанных ограничениях все эти функции являются подходящими для использования в хеш-таблицах.